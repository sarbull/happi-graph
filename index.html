<!doctype html>
<html>

<head>
  <title>D3 Graph</title>

  <style>
    .link-container {}

    .link {
      stroke: #000;
      stroke-width: 2px;
    }

    .node-container>.node {
      cursor: move;
      fill: #fff;
      stroke: #cccccc;
      stroke-width: 1px;
    }

    .node-container>.data {
      fill: #000000;
      white-space: pre;
      font-size: 14px;
      letter-spacing: 0em;
      cursor: move;
      font-family: 'Roboto', sans-serif;
    }

    .node-container>.data>.value {}

    .node-container>.pin {
      fill: #eb4b0b;
    }

    .node-container>.data>.label {
      /* font-weight: 400; */
      fill: #AFAFAF;
    }

    .node {
      cursor: move;
      rx: 40;
      ry: 40;
    }

    .node-container.selected>.node {
      stroke-width: 4px;
      stroke: #eb4b0b;
    }
  </style>
</head>

<body>

  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@100;400&display=swap" rel="stylesheet">

  <button onclick="customZoom(-1);">-</button>
  <button onclick="customZoom(1);">+</button>

  <button onclick="fitContent();">Fit</button>

  <hr>

  <div style="width:100%;background:#eee;">
    <svg width="100%" height="600" style="border: 1px solid black">
      <defs>
        <marker id="arrow-start" markerWidth="10" markerHeight="10" refx="0" refy="3" orient="auto"
          markerUnits="strokeWidth">
          <path d="M9,0 L9,6 L0,3 z" fill="#000" />
        </marker>

        <marker id="arrow-end" markerWidth="10" markerHeight="10" refx="0" refy="3" orient="auto"
          markerUnits="strokeWidth">
          <path d="M0,0 L0,6 L9,3 z" fill="#000" />
        </marker>
      </defs>
    </svg>
  </div>

  <hr>

  <code id="data" style="width:200px;"></code>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.11.0/d3.min.js"></script>

  <script>
    let svg = d3.select('svg');

    let width = +svg.node().getBoundingClientRect().width;
    let height = +svg.node().getBoundingClientRect().height;

    let currentTransformation = {
      translateX: 0,
      translateY: 0,
      scale: 1
    };

    let allGroup =
      svg
        .append('g')
        .attr('class', 'everything');

    let fitContentPadding = 40;

    let linksGroup =
      allGroup
        .append('g')
        .attr('class', 'links');

    let nodesGroup =
      allGroup
        .append('g')
        .attr('class', 'nodes');

    let links = [];
    let nodes = [];

    let onNodeClick = (d) => {
      let e = document.getElementById('data');

      e.innerHTML = JSON.stringify(d);
    }

    let zoom = d3.zoom().on('zoom', zooming);

    function customZoom(value) {
      if (value > 0) {
        zoom.scaleBy(svg.transition(), 1.3);
      } else {
        zoom.scaleBy(svg.transition(), 0.7);
      }
    }

    function zooming() {
      currentTransformation.scale = d3.event.transform.k;
      currentTransformation.translateX = d3.event.transform.x;
      currentTransformation.translateY = d3.event.transform.y;

      allGroup.attr('transform', d3.event.transform);
    }

    svg.call(zoom);

    let nodeWidth = 200;
    let nodeHeight = 150;

    let graph = {
      nodes: [
        {
          id: 'aa',
          fx: 100,
          fy: 100,
          selected: false,
          width: 200,
          height: 75,
          type: 'TYPE1'
        },
        {
          id: 'bb',
          fx: 490,
          fy: 100,
          selected: true,
          width: nodeWidth + 20,
          height: nodeHeight,
          type: 'TYPE1'
        },
        {
          id: 'cc',
          fx: 900,
          fy: 100,
          selected: false,
          width: 200,
          height: 75,
          type: 'TYPE2'
        },
        {
          id: 'dd',
          fx: 1200,
          fy: 100,
          selected: false,
          width: 200,
          height: 75,
          type: 'TYPE1'
        }
      ]
    };

    graph.links = [
      {
        id: '0-1',
        source: graph.nodes[0],
        target: graph.nodes[1],
        connectionToSource: false,
        connectionToTarget: true
      },
      {
        id: '1-2',
        source: graph.nodes[1],
        target: graph.nodes[2],
        connectionToSource: false,
        connectionToTarget: true
      },
      {
        id: '2-3',
        source: graph.nodes[2],
        target: graph.nodes[3],
        connectionToSource: false,
        connectionToTarget: true
      }
    ];

    function getGraphBox() {
      if (graph.nodes.length === 0) {
        return {
          minX: 0,
          minY: 0,
          maxX: 0,
          maxY: 0
        };
      }

      let minX = graph.nodes[0].fx;
      let minY = graph.nodes[0].fy;

      let maxX = minX + graph.nodes[0].width;
      let maxY = minY + graph.nodes[0].height;

      if (graph.nodes.length > 1) {

        for (let i = 1; i < graph.nodes.length; i++) {
          if (graph.nodes[i].fx < minX) {
            minX = graph.nodes[i].fx;
          }
          if (graph.nodes[i].fy < minY) {
            minY = graph.nodes[i].fy;
          }

          if ((graph.nodes[i].fx + graph.nodes[i].width) > maxX) {
            maxX = graph.nodes[i].fx + graph.nodes[i].width;
          }
          if ((graph.nodes[i].fy + graph.nodes[i].height) > maxY) {
            maxY = graph.nodes[i].fy + graph.nodes[i].height;
          }
        }
      }

      return {
        minX: minX,
        minY: minY,
        maxX: maxX,
        maxY: maxY
      };
    }

    function fitContent() {
      var resultTransformation = getFitContentTransformation(currentTransformation);
      var resultTransformation = getCenterContentTransformation(resultTransformation);

      svg.transition()
        .call(
          zoom.transform,
          d3.zoomIdentity
            .translate(resultTransformation.translateX, resultTransformation.translateY)
            .scale(resultTransformation.scale)
        );
    }

    function getCenterContentTransformation(currentTransformation) {
      let graphBox = getGraphBox();

      let graphCenterX = (graphBox.minX + graphBox.maxX) * 0.5 * currentTransformation.scale;
      let graphCenterY = (graphBox.minY + graphBox.maxY) * 0.5 * currentTransformation.scale;

      let svgMidX = width * 0.5;
      let svgMidY = height * 0.5;

      let diffX = svgMidX - graphCenterX;
      let diffY = svgMidY - graphCenterY;

      return {
        translateX: diffX,
        translateY: diffY,
        scale: currentTransformation.scale
      };
    }

    function getFitContentTransformation(currentTransformation) {
      let graphBox = getGraphBox();

      let graphWidth = graphBox.maxX - graphBox.minX;
      graphWidth += fitContentPadding;

      let graphHeight = graphBox.maxY - graphBox.minY;
      graphHeight += fitContentPadding;

      let svgAspectRatio = width / height;
      let graphAspectRatio = graphWidth / graphHeight;

      let newScale = currentTransformation.scale;

      if (graphAspectRatio > svgAspectRatio) {
        newScale = width / graphWidth;
      } else if (graphAspectRatio < svgAspectRatio) {
        newScale = height / graphHeight;
      }

      return {
        translateX: currentTransformation.translateX,
        translateY: currentTransformation.translateY,
        scale: newScale
      };
    }

    let forceProperties = {
      center: {
        x: 0.5,
        y: 0.5
      },
      collide: {
        enabled: true,
        strength: .7,
        iterations: 1,
        radius: nodeWidth
      },
      link: {
        enabled: true,
        distance: 150,
        iterations: 1
      }
    };

    let simulation = d3.forceSimulation();

    function initializeForces() {
      simulation
        .force('link', d3.forceLink().id(d => d.id))
        .force('collide', d3.forceCollide())
        .force('center', d3.forceCenter());
    }

    function updateForces() {
      simulation
        .force('center')
        .x(width * forceProperties.center.x)
        .y(height * forceProperties.center.y);

      simulation
        .force('collide')
        .strength(forceProperties.collide.strength * forceProperties.collide.enabled)
        .radius(forceProperties.collide.radius)
        .iterations(forceProperties.collide.iterations);

      simulation
        .force('link')
        .distance(forceProperties.link.distance)
        .iterations(forceProperties.link.iterations)
        .links(forceProperties.link.enabled ? graph.links : []);
    }

    function restartSimulation() {
      simulation
        .nodes(graph.nodes)
        .on('tick', ticked);

      simulation
        .force('link')
        .links(graph.links);

      simulation
        .alpha(0.3)
        .restart();
    }

    function update() {
      updateLinks();
      updateNodes();

      restartSimulation();
    }

    fitContent();
    initializeForces();
    updateForces();
    update();

    function updateNodes() {
      nodes =
        nodesGroup
          .selectAll('.node-container')
          .data(graph.nodes, (d) => d.id);

      nodes
        .exit()
        .remove();

      let nodeEnter =
        nodes
          .enter();

      nodeEnter = addNodes(nodeEnter);

      nodes =
        nodeEnter
          .merge(nodes);
    }

    function updateLinks() {
      links =
        linksGroup
          .selectAll('.link-container')
          .data(graph.links, (d) => d.id);

      links
        .exit()
        .remove();

      let linkEnter =
        links
          .enter();

      linkEnter = addLinks(linkEnter);

      links =
        linkEnter
          .merge(links);
    }

    function addLinks(enterSelection) {
      const linksContainerSelection =
        enterSelection
          .append('g')
          .classed('link-container', true);

      const linksSelection =
        linksContainerSelection
          .append('line')
          .classed('link', true)
          .attr('data-start', (d) => d.source.id)
          .attr('data-stop', (d) => d.target.id)
          .attr('marker-start', (d) => (d.connectionToSource) ? 'url(#arrow-start)' : '')
          .attr('marker-end', (d) => (d.connectionToTarget) ? 'url(#arrow-end)' : '');

      return linksContainerSelection;
    }

    function addNodes(enterSelection) {
      const nodesContainerSelection =
        enterSelection
          .append('g')
          .attr("transform", function (d) {
            const positionToUseX = (d.fx >= 0) ? d.fx : d.x;
            const positionToUseY = (d.fy >= 0) ? d.fy : d.y;

            return "translate(" + positionToUseX + "," + positionToUseY + ")";
          })
          .on('click', onNodeClick)
          .classed('node-container', true)
          .classed('selected', function (d) { return d.selected; })
          .call(
            d3.drag()
              .on("start", dragstart)
              .on("drag", dragging)
              .on("end", dragend)
          );

      nodesContainerSelection.append("rect")
        .attr('id', function (d) { return d.id })
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', function (d) { return d.width; })
        .attr('height', function (d) { return d.height; })
        .attr('pointer-events', 'visible')
        .classed('node', true);

      let data = nodesContainerSelection
        .append('g')
        .classed('data', true)

      data.append('text')
        .attr('transform', `translate(70, 30)`)
        .classed('value', true)
        .text('FName');

      data.append('text')
        .attr('transform', `translate(70, 50)`)
        .classed('label', true)
        .text('Tabular Column')

      let icon = nodesContainerSelection
        .append('g')
        .attr("transform", `translate(20,20)`);


      icon.append('path')
        .attr('d', 'M38.9711 15C39.8643 16.547 39.8643 18.453 38.9711 20L31.7543 32.5C30.8611 34.047 29.2105 35 27.4241 35H12.9904C11.2041 35 9.55342 34.047 8.66025 32.5L1.44337 20C0.55021 18.453 0.550212 16.547 1.44338 15L8.66026 2.5C9.55342 0.952992 11.2041 0 12.9904 0H27.4241C29.2105 0 30.8611 0.952994 31.7543 2.5L38.9711 15Z')
        .attr('fill', '#5C82EB');

      // TYPE1
      icon.append('path')
        .attr('d', (d) => d.type === 'TYPE1' ? 'M10 9.5V24.5H30V9.5H10ZM26.25 20.75H25V17L21.25 20.75V18.25H13.75V15.75H21.25V13.25L25 17V13.25H26.25V20.75Z' : '')
        .attr('fill', (d) => d.type === 'TYPE1' ? '#ffffff' : '');

      // TYPE2
      icon.append('path')
        .attr('d', (d) => d.type === 'TYPE1' ? 'M10 9.5V24.5H30V9.5H10ZM26.25 20.75H25V17L21.25 20.75V18.25H13.75V15.75H21.25V13.25L25 17V13.25H26.25V20.75Z' : '')
        .attr('fill', (d) => d.type === 'TYPE1' ? '#ffffff' : '');
      icon.append('path')
          .attr('d', (d) => d.type === 'TYPE2' ? 'M20 2.5H18.75V0H6.25V2.5H3.75V4.0625L3 5H1.25V7.1875L0 8.75V20H15L20 13.75V2.5ZM2.5 6.25H12.5V8.75H2.5V6.25ZM13.75 18.75H1.25V10H13.75V18.75ZM15 8.75H13.75V5H5V3.75H15V8.75ZM17.5 5.625L16.25 7.1875V2.5H7.5V1.25H17.5V5.625Z' : '')
          .attr('fill', (d) => d.type === 'TYPE2' ? '#ffffff' : '');

      let pin = nodesContainerSelection
        .append('path')
        .classed('pin', true)
        .attr('d', (d) => {
          if (d.selected) {
            return 'M7 2h10v2l-2 1v5l3 3v3h-5v4l-1 3l-1-3v-4H6v-3l3-3V5L7 4z';
          }
        })
        .attr('transform', (d) => {
          let x = d.width - 30;
          let y = 10;

          return `translate(${x} ${y}) rotate(30 0 0)`;
        });

      return nodesContainerSelection;
    }




    // update the display positions after each simulation tick
    function ticked() {
      let calculateNodeCenterX = (nodeX) => {
        return nodeX + (50 + 2 * 10) / 2;
      };

      let calculateNodeCenterY = (nodeY) => {
        return nodeY + (50 + 2 * 10) / 2;
      };

      links
        .selectAll('.link')
        .each(function (data) {
          const intersection = getIntersection(data.source, data.target);

          d3.select(this)
            .attr('x1', () => {
              let calculatedEndX = calculateNodeCenterX(data.source.x);

              if (intersection) {
                calculatedEndX = intersection.x1;
              }

              return calculatedEndX;
            })
            .attr('y1', () => {
              let calculatedEndX = calculateNodeCenterY(data.source.y);

              if (intersection) {
                calculatedEndX = intersection.y1;
              }

              return calculatedEndX;
            })
            .attr('x2', () => {
              let calculatedEndX = calculateNodeCenterX(data.target.x);

              if (intersection) {
                calculatedEndX = intersection.x2;
              }

              return calculatedEndX;
            })
            .attr('y2', () => {
              let calculatedEndY = calculateNodeCenterY(data.target.y);

              if (intersection) {
                calculatedEndY = intersection.y2;
              }

              return calculatedEndY;
            });
        });

      nodes
        .attr('transform', (d) => {
          const positionToUseX = (d.fx >= 0) ? d.fx : d.x;
          const positionToUseY = (d.fy >= 0) ? d.fy : d.y;

          return `translate(${positionToUseX},${positionToUseY})`;
        });
    }

    function dragstart(d) {
      if (!d3.event.active) {
        simulation.alphaTarget(0.3).restart();
      }

      d.fx = d.x;
      d.fy = d.y;
    }

    function dragging(d) {
      d.fx = d3.event.x;
      d.fy = d3.event.y;
    }

    function dragend(d) {
      if (!d3.event.active) {
        simulation.alphaTarget(1);
      }

      d.x = d.fx;
      d.y = d.fy;
    }

    function Point(x, y) {
      if (!(this instanceof Point)) {
        return new Point(x, y);
      }
      this.x = x;
      this.y = y;
    }
    Point.add = function (a, b) {
      return Point(a.x + b.x, a.y + b.y);
    }
    Point.sub = function (a, b) {
      return Point(a.x - b.x, a.y - b.y);
    }
    Point.cross = function (a, b) {
      return a.x * b.y - a.y * b.x;
    }
    Point.scale = function (a, k) {
      return Point(a.x * k, a.y * k);
    }
    Point.unit = function (a) {
      return Point.scale(a, 1 / Point.magnitude(a));
    }
    Point.magnitude = function (a) {
      return Math.sqrt(a.x * a.x + a.y * a.y);
    }
    Point.eq = function (a, b) {
      return Math.abs(a.x - b.x) < 1e-6 && Math.abs(a.y - b.y) < 1e-6;
    }

    function pointInSegment(s, p) {
      var a = s[0];
      var b = s[1];
      return Math.abs(Point.cross(Point.sub(p, a), Point.sub(b, a))) < 1e-6 && Math.min(a.x, b.x) <= p.x && p.x <= Math.max(a.x, b.x) && Math.min(a.y, b.y) <= p.y && p.y <= Math.max(a.y, b.y);
    }

    function lineLineIntersection(s1, s2) {
      var a = s1[0];
      var b = s1[1];
      var c = s2[0];
      var d = s2[1];
      var v1 = Point.sub(b, a);
      var v2 = Point.sub(d, c);
      if (Math.abs(Point.cross(v1, v2)) < 1e-6) {
        // collinear
        return null;
      }
      var kNum = Point.cross(
        Point.sub(c, a),
        Point.sub(d, c)
      );
      var kDen = Point.cross(
        Point.sub(b, a),
        Point.sub(d, c)
      );
      var ip = Point.add(
        a,
        Point.scale(
          Point.sub(b, a),
          Math.abs(kNum / kDen)
        )
      );
      return ip;
    }

    function segmentSegmentIntersection(s1, s2) {
      var ip = lineLineIntersection(s1, s2);
      if (ip && pointInSegment(s1, ip) && pointInSegment(s2, ip)) {
        return ip;
      }
    }

    function boxSegmentIntersection(box, lineSegment) {
      var topLeft = Point(box.x, box.y);
      var topRight = Point(box.x + box.width, box.y);
      var botLeft = Point(box.x, box.y + box.height);
      var botRight = Point(box.x + box.width, box.y + box.height);
      var boxSegments = [
        // top
        [topLeft, topRight],
        // bot
        [botLeft, botRight],
        // left
        [topLeft, botLeft],
        // right
        [topRight, botRight]
      ];
      var ip;
      for (var i = 0; !ip && i < 4; i += 1) {
        ip = segmentSegmentIntersection(boxSegments[i], lineSegment);
      }
      return ip;
    }

    function boxCenter(a) {
      return Point(
        a.x + a.width / 2,
        a.y + a.height / 2
      );
    }

    function buildSegmentThroughCenters(a, b) {
      return [boxCenter(a), boxCenter(b)];
    }

    // should return {x1, y1, x2, y2}
    function getIntersection(a, b) {
      var segment = buildSegmentThroughCenters(a, b);
      var ia = boxSegmentIntersection(a, segment);
      var ib = boxSegmentIntersection(b, segment);
      if (ia && ib && !Point.eq(ia, ib)) {

        // problem: the arrows are drawn after the intersection with the box
        // solution: move the arrow toward the other end

        var unitV = Point.unit(Point.sub(ib, ia));
        // k = the width of the marker
        var k = 18;
        ib = Point.sub(ib, Point.scale(unitV, k));

        return {
          x1: ia.x,
          y1: ia.y,
          x2: ib.x,
          y2: ib.y
        }
      }
    }
  </script>

</body>

</html>